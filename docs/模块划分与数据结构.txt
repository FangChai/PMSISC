模块划分与数据结构

1.模块划分

csismp_collector:
功能：
获取字典序最小的网卡，用一个pcap_loop从字典序中不停地收取感兴趣的分片
探测在分片整合成会话过程中的错误（tlv信息出错，分片号出错，超时等等），并回应rjt
整合合法的会话，封装成session结构（参见数据结构一节）异步传递给processor（此处使用多线程异步处理以保证迅速处理接下来的包）
循环上述过程
接口：
void start_collector(); //初始化并启动整个处理流程

csismp_processor
功能：
收到session结构后，按照会话的类型执行相应操作（add，del，syn）
对高层错误（删除不存在的学生，会话中id重复等等）回复rjt，若没有错误则回复ack
在有了第一个学生信息之后，创建一个timer，每30秒发送一次同步报文
对于学生信息的改变，将新的学生信息输出到StuInfo.txt
接口：
void* process_session(void *conv); //pthread起始函数, 处理session
void init_processor(); //初始化

csismp_sender
功能：
收到session结构后，将其拆分成大小合适的分片（最少分片原则），并整合成符合报文规范的报文集合发送到目的mac
接口：
int send_session(const struct session& s); //发送session
void init_sender(); //初始化sender

csismp_config
功能：
完成mac的读取写入工作，并且为collector和sender提供mac配置
接口：
mac_configure(const string &s); \\mac_configure类构造函数，读入配置文件
write(const string &s)； \\按格式写出配置文件

csismp_timer
功能：
timer管理模块，管理每个会话的超时，若超过五秒，通知collector拒绝会话
接口：
int init_timer(void (*func)(mac_id_pair_t, session_type));  \\初始化时钟
int add_timer(mac_id_pair_t p, session_type type); \\为mac_session-id二元组分配超时时钟
int del_timer(mac_id_pair_t p); \\删除时钟


2.数据结构
所有核心模块之间通过session结构来传递数据，struct session定义如下：
enum session_type {
        SESSION_ADD = 1,
        SESSION_DEL,
        SESSION_ACK,
        SESSION_RJT,
        SESSION_SYN
};

struct student_info {
        string id;
        string name;
        string faculty;
};

struct session {
        uint32_t session_id;
        uint8_t source_mac[6];
        session_type type;
        vector<struct student_info> info_list;
};




